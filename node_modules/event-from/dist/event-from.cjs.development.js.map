{"version":3,"file":"event-from.cjs.development.js","sources":["../src/index.ts"],"sourcesContent":["export type EventFromInput = 'mouse' | 'touch' | 'key';\n\nlet recentEventFrom: EventFromInput = 'key';\nlet recentFocusFrom: EventFromInput = recentEventFrom;\nlet recentTouch = false;\nlet recentMouse = false;\nlet recentWindowFocus = false;\n\n// To determine if there was a recentTouch event\n// use setTimeout instead of a Date.now() comparison because\n// in the case of a long running/blocking process from a touch event,\n// the browser will push the corresponding mouse event (created by the touch interaction)\n// onto the callback queue at the time it should be executed,\n// and then push the timeout function onto the queue after the timer expires,\n// even if the the main thread is still blocked (because the browser is multi-threaded).\n// This results in the mouse event being moved to the callstack and called\n// before the timeout function so recentTouch is still true\n// regardless of how many Date.now() seconds have gone by.\n// Also, if subsequent touch events occur while the blocking process is running,\n// the browser will push the touch events onto the queue when the touch happens,\n// and if one of them is in queue before the previous touch event's timer expires,\n// it will be called before the timeout's function (so it can reset the timer),\n// and, this is the key part, if the previous timer has finished and it's callback is added to the queue,\n// the call to clearTimeout(recentTouchTimeoutId) will remove the timeout's function from the callback queue.\nlet recentTouchTimeoutId: number | undefined;\nconst setRecentEventFromTouch = (touchDelay: number) => {\n  recentTouch = true;\n  recentEventFrom = 'touch';\n\n  window.clearTimeout(recentTouchTimeoutId);\n  recentTouchTimeoutId = window.setTimeout(() => {\n    recentTouch = false;\n  }, touchDelay);\n};\n\nlet recentMouseTimeoutId: number | undefined;\nconst setRecentEventFromMouse = () => {\n  recentMouse = true;\n  recentEventFrom = 'mouse';\n\n  window.clearTimeout(recentMouseTimeoutId);\n  recentMouseTimeoutId = window.setTimeout(() => {\n    recentMouse = false;\n  }, 200);\n};\n\nconst handleTouchEvent = (touchDelay: number) => () =>\n  setRecentEventFromTouch(touchDelay);\n\nconst handlePointerEvent = (touchDelay: number) => (e: PointerEvent) => {\n  switch (e.pointerType) {\n    case 'mouse':\n      setRecentEventFromMouse();\n      break;\n    case 'pen':\n    case 'touch':\n      setRecentEventFromTouch(touchDelay);\n      break;\n  }\n};\n\nconst handleMouseEvent = () => {\n  if (!recentTouch) {\n    setRecentEventFromMouse();\n  }\n};\n\nconst handleKeyEvent = () => {\n  recentEventFrom = 'key';\n};\n\n// recentFocusFrom tracking\n// set document focus event capture listener which sets recentFocusFrom equal to recentEventFrom\n// except if there is a recent window focus event where the window is the target (unless there is also a recent mouse or touch event),\n// in which case leave recentFocusFrom unchanged to maintain correct recentFocusFrom after switching apps/windows/tabs/etc,\n// if/when the focus event is passed into eventFrom later in the cycle, just return recentFocusFrom.\n// for tracking recent window focus, set window focus capture event listener,\n// if the target is window (or document on firefox), then track recentWindowFocus with setTimeout 300\nlet recentWindowFocusTimeoutId: number | undefined;\nconst handleWindowFocusEvent = (e: FocusEvent) => {\n  if (e.target === window || e.target === document) {\n    recentWindowFocus = true;\n\n    window.clearTimeout(recentWindowFocusTimeoutId);\n    recentWindowFocusTimeoutId = window.setTimeout(() => {\n      recentWindowFocus = false;\n    }, 300);\n  }\n};\n\nconst handleDocumentFocusEvent = () => {\n  if (!recentWindowFocus || recentMouse || recentTouch) {\n    recentFocusFrom = recentEventFrom;\n  }\n};\n\nconst listenerOptions = { capture: true, passive: true };\n\nconst documentListeners = [\n  ['touchstart', handleTouchEvent(750)],\n  ['touchend', handleTouchEvent(300)],\n  ['touchcancel', handleTouchEvent(300)],\n  ['pointerenter', handlePointerEvent(300)],\n  ['pointerover', handlePointerEvent(300)],\n  ['pointerout', handlePointerEvent(300)],\n  ['pointerleave', handlePointerEvent(300)],\n  ['pointerdown', handlePointerEvent(750)],\n  ['pointerup', handlePointerEvent(300)],\n  ['pointercancel', handlePointerEvent(300)],\n  ['mouseenter', handleMouseEvent],\n  ['mouseover', handleMouseEvent],\n  ['mouseout', handleMouseEvent],\n  ['mouseleave', handleMouseEvent],\n  ['mousedown', handleMouseEvent],\n  ['mouseup', handleMouseEvent],\n  ['keydown', handleKeyEvent],\n  ['keyup', handleKeyEvent],\n  ['focus', handleDocumentFocusEvent],\n];\n\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  documentListeners.forEach(([eventName, eventHandler]) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore not sure how to get TS to match the handler type to the specific eventName\n    document.addEventListener(eventName, eventHandler, listenerOptions);\n  });\n\n  window.addEventListener('focus', handleWindowFocusEvent, listenerOptions);\n}\n\n// temporarily set the return value for eventFrom(e)\n// note that the eventFrom(e) value will change when new events come in\n// useful when manually generating events, e.g. el.focus() or el.click()\n// and you want eventFrom(e) to treat that event as occurring from a specific input\nexport const setEventFrom = (value: EventFromInput): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (value !== 'mouse' && value !== 'touch' && value !== 'key') {\n      throw Error(\n        `setEventFrom function requires argument of \"mouse\" | \"touch\" | \"key\", argument received: ${value}`,\n      );\n    }\n  }\n  if (value === 'mouse' || value === 'touch' || value === 'key') {\n    recentEventFrom = value;\n    recentFocusFrom = value;\n  }\n};\n\n// use any instead of unknown b/c unknown causes type error when passing a react synthetic event\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const eventFrom = (event: Record<string, any>): EventFromInput => {\n  // use the incoming event to help determine recentEventFrom\n  // in the same manner as the document event listeners\n  // this helps catch edge cases especially when a move event is passed to eventFrom\n  // because move event listeners are not set by Event From\n  switch (event.pointerType) {\n    case 'mouse':\n      setRecentEventFromMouse();\n      break;\n    case 'pen':\n    case 'touch':\n      if (!recentTouch) {\n        setRecentEventFromTouch(300);\n      } else {\n        recentEventFrom = 'touch';\n      }\n      break;\n  }\n\n  if (/mouse/.test(event.type) && !recentTouch) {\n    setRecentEventFromMouse();\n  }\n\n  if (/touch/.test(event.type)) {\n    if (!recentTouch) {\n      setRecentEventFromTouch(300);\n    } else {\n      recentEventFrom = 'touch';\n    }\n  }\n\n  // focus events return recentFocusFrom, see recentFocusFrom tracking note above\n  if (/focus/.test(event.type)) {\n    return recentFocusFrom;\n  }\n\n  return recentEventFrom;\n};\n\n// note that edge cases exist for scroll and wheel events where eventFrom will return the wrong input,\n// to fix this, event-from would need to set a 'wheel' event listener on the document (see below),\n// but decided not to add it because 'wheel' is a high frequency event (like move events)\n// and don't currently have a use case for eventFrom(scrollEvent)\n// to add support:\n//   document.addEventListener(\n//     'wheel',\n//     () => {\n//       // might need to track wheel event separately and use it just for eventFrom(scroll)\n//       // because the wheel event is elastic, it continues to fire after the user interaction has finished\n//       recentEventFrom = 'mouse';\n//     },\n//     listenerOptions,\n//   );\n"],"names":[],"mappings":"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"}