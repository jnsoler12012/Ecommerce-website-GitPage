'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var eventFrom = require('event-from');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

const stateChanged = ({ state, prevState, }) => state.hover !== prevState.hover ||
    state.active !== prevState.active ||
    state.focus !== prevState.focus;
// elements triggered by the enter key, used to determine the keyActive state
const enterKeyTrigger = ({ tagName, type }) => tagName !== 'SELECT' &&
    (tagName !== 'INPUT' || (type !== 'checkbox' && type !== 'radio'));
// elements triggered by the space bar, used to determine the keyActive state
const spaceKeyTrigger = ({ tagName, type }) => ['BUTTON', 'SELECT'].includes(tagName) ||
    (tagName === 'INPUT' &&
        ['checkbox', 'radio', 'submit'].includes(type));
// elements that support the disabled attribute
const elementSupportsDisabled = ({ tagName }) => ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FIELDSET'].includes(tagName);
// elements that should have cursor: pointer b/c clicking does something
const cursorPointer = ({ tagName, type }, hasOnClickHandler) => ['BUTTON', 'A', 'AREA', 'SELECT'].includes(tagName) ||
    (tagName === 'INPUT' &&
        ['checkbox', 'radio', 'submit'].includes(type)) ||
    (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && hasOnClickHandler);
// mimic react's treatment of className prop
// objects (including arrays) and numbers/bigints
// are converted to strings, the rest are ignored
const classNameToString = (className) => typeof className === 'string' ||
    (typeof className === 'object' && className !== null) ||
    typeof className === 'number' ||
    typeof className === 'bigint'
    ? String(className)
    : '';
// used for useExtendedTouchActive which needs to set user-select: none
// to prevent the browser from selecting text on long touch
// note that it needs to be set on the body not the RI element
// because iOS will still select nearby text
let pendingUserSelectReset = false;
const setUserSelectNone = () => {
    pendingUserSelectReset = false;
    document.body.style.userSelect = 'none';
    document.body.style.webkitUserSelect = 'none';
};
const resetUserSelect = () => {
    pendingUserSelectReset = true;
    // use setTimeout delay for reset because iOS will select text shortly after touch end
    // when the touch end event occurs near the time that iOS would normally select text
    window.setTimeout(() => {
        if (pendingUserSelectReset) {
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
        }
    }, 250);
};

const initialState = {
    hover: false,
    active: false,
    focus: false,
};
// event listeners set by RI
const eventMap = {
    mouseover: 'onMouseOver',
    mouseleave: 'onMouseLeave',
    mousedown: 'onMouseDown',
    mouseup: 'onMouseUp',
    pointerover: 'onPointerOver',
    pointerleave: 'onPointerLeave',
    pointerdown: 'onPointerDown',
    pointerup: 'onPointerUp',
    pointercancel: 'onPointerCancel',
    touchstart: 'onTouchStart',
    touchend: 'onTouchEnd',
    touchcancel: 'onTouchCancel',
    keydown: 'onKeyDown',
    keyup: 'onKeyUp',
    focus: 'onFocus',
    blur: 'onBlur',
    dragstart: 'onDragStart',
    dragend: 'onDragEnd',
};
const eventListenerPropNames = Object.values(eventMap);
const defaultAs = 'button';
// InteractiveNotMemoized is wrapped in React.memo() and exported at the end of this file
const InteractiveNotMemoized = React__namespace.forwardRef(function ({ as, children, onStateChange, disabled = false, useExtendedTouchActive = false, hoverClassName = 'hover', activeClassName = 'active', mouseActiveClassName = 'mouseActive', touchActiveClassName = 'touchActive', keyActiveClassName = 'keyActive', focusClassName = 'focus', focusFromKeyClassName = 'focusFromKey', focusFromMouseClassName = 'focusFromMouse', focusFromTouchClassName = 'focusFromTouch', disabledClassName = 'disabled', hoverStyle, activeStyle, mouseActiveStyle, touchActiveStyle, keyActiveStyle, focusStyle, focusFromKeyStyle, focusFromMouseStyle, focusFromTouchStyle, disabledStyle, ...restProps }, ref) {
    ////////////////////////////////////
    // what RI is rendered as in the DOM, default is <button>
    const As = as || defaultAs;
    ////////////////////////////////////
    // interactive state of the component (hover, active, focus)
    // save both current and previous state to pass to onStateChange prop callback
    const [iState, setIState] = React__namespace.useState({
        state: initialState,
        prevState: initialState,
    });
    // used as a dependency for useEffect, as well as for logic involving useExtendedTouchActive
    const inTouchActiveState = iState.state.active === 'touchActive';
    ////////////////////////////////////
    // onStateChange prop callback
    React__namespace.useEffect(() => {
        if (onStateChange) {
            onStateChange(iState);
        }
    }, 
    // only call this effect if the current state has changed
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [iState.state.hover, iState.state.active, iState.state.focus]);
    ////////////////////////////////////
    // if disabled and As is a component, will need to re-render if there is a new ref
    // to know if the DOM element supports disabled because don't have access to the DOM element on the first render,
    // the forceUpdate only happens after the first render (and only if disabled and As component),
    // and when the As component renders a different DOM element while in the disabled state
    const disabledAndAsComponent = React__namespace.useRef(false);
    disabledAndAsComponent.current = disabled && typeof As !== 'string';
    const [, forceUpdateDisabledComponent] = React__namespace.useState(false);
    ////////////////////////////////////
    // support passed in ref prop as object or callback, and track ref locally
    const localRef = React__namespace.useRef(null);
    const callbackRef = React__namespace.useCallback((node) => {
        localRef.current = node;
        if (typeof ref === 'function') {
            ref(node);
        }
        else if (ref) {
            ref.current = node;
        }
        // if disabled and As is a component, and receive a new ref (i.e. callbackRef is called)
        // then re-render to pass the disabled prop to the As component if the DOM element supports it
        if (disabledAndAsComponent.current) {
            forceUpdateDisabledComponent((s) => !s);
        }
    }, [ref]);
    ////////////////////////////////////
    // track enter key and space key state (down/up) as ref
    // used to determine keyActive state
    const keyTracking = React__namespace.useRef({ enterKeyDown: false, spaceKeyDown: false });
    // track if the element is being dragged
    // used to stay in the respective active state while dragging
    const dragTracking = React__namespace.useRef({ isDragging: false });
    const stateChange = React__namespace.useCallback((...changes) => {
        setIState((previous) => {
            const newState = { ...previous.state };
            // stateChange accepts multiple changes in each function call
            // so update the newState for each change received
            changes.forEach(({ iStateKey, state, action }) => {
                if (action === 'enter') {
                    // TS should known that iStateKey and state values are matched to each other
                    // based on the StateChangeFunction type above, but TS doesn't understand this, so use as any
                    newState[iStateKey] = state;
                }
                else if (
                // only exit a state (to false) if currently in that state
                action === 'exit' &&
                    previous.state[iStateKey] === state &&
                    // if currently dragging the element, then don't exit the active state
                    (!dragTracking.current.isDragging || iStateKey !== 'active')) {
                    newState[iStateKey] = false;
                }
            });
            const newInteractiveStateChange = {
                state: newState,
                prevState: previous.state,
            };
            // if the state has changed (deep equal comparison), then return the newInteractiveStateChange
            // otherwise bail on the setIState call and return the previous state (object with referential equality)
            return stateChanged(newInteractiveStateChange)
                ? newInteractiveStateChange
                : previous;
        });
    }, []);
    ////////////////////////////////////
    // react bug where the blur event is not dispatched when a button becomes disabled
    // see https://github.com/facebook/react/issues/9142
    // so break out blurInteractive() as it's own function
    // to be called from the blur event handler (normal behavior)
    // and the below useEffect (workaround for react bug)
    const blurInteractive = React__namespace.useCallback(() => {
        // reset keyTracking when the element is blurred (can't be the target of key events)
        keyTracking.current.enterKeyDown = false;
        keyTracking.current.spaceKeyDown = false;
        stateChange({
            iStateKey: 'focus',
            state: false,
            action: 'enter',
        }, {
            iStateKey: 'active',
            state: 'keyActive',
            action: 'exit',
        });
    }, [stateChange]);
    // if RI is disabled and in a focus state, then call blur on the DOM element and blurInteractive()
    React__namespace.useEffect(() => {
        if (disabled &&
            iState.state.focus &&
            // if As is a Component that renders an element which doesn't support the disabled attribute (so disabled not passed to the DOM element)
            // then don't do anything as have no control over what gets rendered (better to just do no harm)
            // note that for DOM elements that don't support disabled but As is a string (e.g. as="div", as="a")
            // this works b/c RI also sets tabIndex and href to undefined when disabled which makes the element not focusable
            // otherwise would get a flash of focus and then blur if the user tried to re-focus the element
            (elementSupportsDisabled(localRef.current || {}) ||
                typeof As === 'string')) {
            // when a button that currently has focus is disabled there are bugs in both firefox (v87) and safari (v14)
            // firefox doesn't dispatch a blur event (button is still document.activeElement) but key events are no longer registered on the button, https://bugzilla.mozilla.org/show_bug.cgi?id=1650092
            // safari leaves focus on the button (no blur event) and key events are still registered, but once focus leaves the button it can't be re-focused
            // so call blur() on the DOM element to fix these bugs
            if (localRef.current &&
                typeof localRef.current.blur === 'function') {
                localRef.current.blur();
            }
            blurInteractive();
        }
    }, [disabled, iState.state.focus, blurInteractive, As]);
    ////////////////////////////////////
    // handleEvent handles all events that change the interactive state of the component
    // for example <As onMouseOver={handleEvent} onPointerOver={handleEvent} etc...>
    // always set all pointer/mouse/touch event listeners
    // instead of just pointer event listeners (when supported by the browser)
    // or mouse and touch listeners when pointer events are not supported
    // because
    //   - 1. the pointer events implementation is buggy on some devices
    //        so pointer events on its own is not a good option
    //        for example, on iPadOS pointer events from mouse will cease to fire for the entire page
    //        after using mouse and touch input at the same time (note that mouse events are unaffected)
    //   - 2. the pointercancel event is useful for syncing the touchActive state with browser generated click events
    //        as it fires as soon as the browser uses the touch interaction for another purpose (e.g. scrolling)
    //        and this can't be replicated with touch events (touchcancel behaves differently)
    //   - 3. the touchend/cancel event is useful to support useExtendedTouchActive as it won't fire until the
    //        the touch point is removed from the screen, which can only be replicated with pointer events
    //        if touch-action: none is set on the element, which has unwanted side effects (e.g. can't scroll if the touch started on the element)
    // so instead of trying to identify and work around all of the edge cases and bugs and set different listeners in each situation
    // the solution is to always set all listeners and make the stateChange function idempotent
    // and bail on updating state in setIState if the state hasn't changed to prevent unnecessary renders
    // also note that setting listeners for events not supported by the browser has no effect
    // note: use onMouseOver and onPointerOver instead of onMouseEnter and onPointerEnter because
    // of a react bug where enter events are not dispatched on an element when the element above it is removed,
    // this also effects when navigating around a single page app where the user clicks on a link
    // and the element that's rendered on the new page under the mouse doesn't receive enter events
    // see: https://github.com/facebook/react/issues/13956
    // note that since stateChange is idempotent the extra mouse/pointer over events will have no effect
    // useCallback so event handlers passed to <As> are referentially equivalent between renders
    const handleEvent = React__namespace.useCallback((e) => {
        // nested switch statement to determine the appropriate stateChange
        // uses both e.type and eventFrom(e) in its routing logic
        // switch on e.type
        //   focus -> focus: enter focusFrom[eventFrom(e)]
        //   blur -> focus: enter false, active: exit keyActive
        //   keydown -> active: enter keyActive
        //   keyup -> active: exit keyActive
        //   dragstart -> active: enter `${eventFrom(e)}Active`
        //   dragend -> active: enter false
        //   default switch on eventFrom(e)
        //     eventFrom mouse
        //       switch on e.type
        //         mouse/pointer over -> hover: enter true
        //         mouse/pointer leave, pointercancel -> hover: enter false, active: exit mouseActive
        //         mouse/pointer down -> active: enter mouseActive
        //         mouse/pointer up -> active: exit mouseActive
        //     eventFrom touch
        //       switch on e.type
        //         touchstart/pointerdown -> active: enter touchActive
        //         touchend/pointerup/touchcancel/pointercancel/mouseover -> active: exit touchActive
        //         mouseleave -> hover: enter false, active: exit mouseActive
        switch (e.type) {
            case 'focus':
                // only enter focus state if RI is the target of the focus event (focus events bubble in react)
                if (e.target === localRef.current) {
                    stateChange({
                        iStateKey: 'focus',
                        state: `focusFrom${eventFrom.eventFrom(e).replace(/^\w/, (c) => c.toUpperCase())}`,
                        action: 'enter',
                    });
                }
                break;
            case 'blur':
                // break out blur logic as a separate function because of a react bug
                // where the blur event is not dispatched when a button becomes disabled
                // so also need to call blurInteractive() after receiving a disabled prop
                blurInteractive();
                break;
            case 'keydown':
            case 'keyup':
                // update keyTracking and bail if the event is not from the space or enter key
                if (e.key === ' ') {
                    keyTracking.current.spaceKeyDown = e.type === 'keydown';
                }
                else if (e.key === 'Enter') {
                    keyTracking.current.enterKeyDown = e.type === 'keydown';
                }
                else {
                    // break (bail out) if e.key is not the space or enter key so stateChange isn't called
                    break;
                }
                stateChange({
                    iStateKey: 'active',
                    state: 'keyActive',
                    action: 
                    // use space and enter key down state to determine the enter/exit action
                    // based on what keys trigger the the RI element
                    // some elements are triggered by the space key, some by the enter key, and some by both
                    (keyTracking.current.enterKeyDown &&
                        enterKeyTrigger(localRef.current || {})) ||
                        (keyTracking.current.spaceKeyDown &&
                            spaceKeyTrigger(localRef.current || {}))
                        ? 'enter'
                        : 'exit',
                });
                break;
            case 'dragstart':
                dragTracking.current.isDragging = true;
                stateChange({
                    iStateKey: 'active',
                    state: `${eventFrom.eventFrom(e)}Active`,
                    action: 'enter',
                });
                break;
            case 'dragend':
                dragTracking.current.isDragging = false;
                stateChange({
                    iStateKey: 'active',
                    state: false,
                    action: 'enter',
                });
                break;
            default:
                // switch on eventFrom for pointer, mouse, and touch events
                // for example, a mouse event from mouse input is very different than a mouse event from touch input
                switch (eventFrom.eventFrom(e)) {
                    case 'mouse':
                        switch (e.type) {
                            case 'mouseover':
                            case 'pointerover':
                                stateChange({
                                    iStateKey: 'hover',
                                    state: true,
                                    action: 'enter',
                                });
                                break;
                            case 'mouseleave':
                            case 'pointerleave':
                            case 'pointercancel':
                                stateChange({
                                    iStateKey: 'hover',
                                    state: false,
                                    action: 'enter',
                                }, 
                                // leave events also exit mouseActive because after the mouse leaves, mouseup events are not fired on the element
                                // for example, mouse enter -> button down -> mouse leave -> button up, would leave RI stuck in the mouseActive state
                                {
                                    iStateKey: 'active',
                                    state: 'mouseActive',
                                    action: 'exit',
                                });
                                break;
                            case 'mousedown':
                            case 'pointerdown':
                                stateChange({
                                    iStateKey: 'active',
                                    state: 'mouseActive',
                                    action: 'enter',
                                });
                                break;
                            case 'mouseup':
                            case 'pointerup':
                                stateChange({
                                    iStateKey: 'active',
                                    state: 'mouseActive',
                                    action: 'exit',
                                });
                                break;
                        }
                        break;
                    case 'touch':
                        switch (e.type) {
                            case 'touchstart':
                            case 'pointerdown':
                                stateChange({
                                    iStateKey: 'active',
                                    state: 'touchActive',
                                    action: 'enter',
                                });
                                break;
                            case 'touchend':
                            case 'touchcancel':
                            case 'pointerup':
                            case 'pointercancel':
                            // exit touchActive on mouseover eventFrom touch
                            // because on android, mouse events (and focus and context menu) fire ~500ms after touch start
                            // once they fire, click will never be fired, so exit touchActive
                            // eslint-disable-next-line no-fallthrough
                            case 'mouseover':
                                // if useExtendedTouchActive then only exit touchActive on touchend and touchcancel events
                                // which won't fire until the touch point is removed from the screen
                                if (!useExtendedTouchActive ||
                                    ['touchend', 'touchcancel'].includes(e.type)) {
                                    stateChange({
                                        iStateKey: 'active',
                                        state: 'touchActive',
                                        action: 'exit',
                                    });
                                }
                                break;
                            // when using both mouse and touch input on a hybrid device the following can happen:
                            // the mouse enters an RI element, so hover: true,
                            // then tap someplace else on the screen which fires a mouseleave event
                            // this is correctly treated as an eventFrom touch (caused by a touch interaction)
                            // but RI is now stuck in the hover state
                            // so RI needs to exit the hover state on a mouseleave eventFrom touch,
                            // note that if no scrolling is involved this is not too bad because
                            // when the mouse is used again it will be over the RI element (and will fire mouseover event),
                            // but if the user scrolled with the touch interaction then RI will be stuck in the hover state
                            // until the user re-hovers and exits the RI element with their mouse, which is bad,
                            // also note that on touch only devices this stateChange call will have no effect because RI is never in the hover or mouseActive states
                            case 'mouseleave':
                                stateChange({
                                    iStateKey: 'hover',
                                    state: false,
                                    action: 'enter',
                                }, {
                                    iStateKey: 'active',
                                    state: 'mouseActive',
                                    action: 'exit',
                                });
                                break;
                        }
                        break;
                }
                break;
        }
        // call event handler prop for the current event if the prop is passed in
        if (restProps[eventMap[e.type]]) {
            restProps[eventMap[e.type]](e);
        }
    }, 
    // handleEvent is dependent on event handler props that are also in eventMap
    // for example, restProps.onMouseOver, restProps.onTouchStart, etc
    // this generates an array of event handler props that are also in eventMap
    // handleEvent is also dependent on stateChange, but this will always be referentially equivalent
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        // eslint-disable-next-line react-hooks/exhaustive-deps
        ...eventListenerPropNames.map((listenerPropName) => restProps[listenerPropName]),
        useExtendedTouchActive,
        stateChange,
        blurInteractive,
    ]);
    ////////////////////////////////////
    // create object with event listeners to pass to <As {...eventListeners}>
    const eventListeners = {};
    eventListenerPropNames.forEach((listenerPropName) => {
        eventListeners[listenerPropName] = handleEvent;
    });
    ////////////////////////////////////
    // to sync the touchActive state with the click event fired by the browser
    // only stay in the touchActive state for a max of 750ms
    // note that most of the time another event (up/end/cancel) will exit touchActive before the timer finishes
    // in which case the effect clean up will run (because inTouchActiveState state changed)
    // and the timer will be cleared
    // track touchActive timer id as ref
    const touchActiveTimeoutId = React__namespace.useRef(undefined);
    // effect run on touchActive state change, or if useExtendedTouchActive prop changes
    // it will always clear the existing timer before potentially setting a new one
    React__namespace.useEffect(() => {
        if (inTouchActiveState && !useExtendedTouchActive) {
            touchActiveTimeoutId.current = window.setTimeout(() => {
                stateChange({
                    iStateKey: 'active',
                    state: 'touchActive',
                    action: 'exit',
                });
            }, 750);
            return () => window.clearTimeout(touchActiveTimeoutId.current);
        }
        return;
    }, [inTouchActiveState, useExtendedTouchActive, stateChange]);
    ////////////////////////////////////
    // set user-select: none when useExtendedTouchActive and in the touchActive state
    // to prevent the browser from selecting text on long touch
    // note that it needs to be set on the body not the RI element
    // because iOS will still select nearby text if it is only set on the element
    React__namespace.useEffect(() => {
        if (inTouchActiveState && useExtendedTouchActive) {
            setUserSelectNone();
            return resetUserSelect;
        }
        return;
    }, [inTouchActiveState, useExtendedTouchActive]);
    ////////////////////////////////////
    // compute className and style props based on the current state
    // css classes are merged into this string
    let className = classNameToString(restProps.className);
    // style objects are merged into this object with the following precedence:
    // style object <= default styles <= style prop <= (disabledStyle || hoverStyle <= activeStyle <= [input]ActiveStyle <= focusStyle <= focusFrom[input]Style)
    const style = {};
    // add default styles
    if (
    // if clicking does something and RI is not disabled, then set the cursor to pointer for better UX
    !disabled &&
        cursorPointer(localRef.current || {}, Boolean(restProps.onClick || restProps.onClickCapture))) {
        style.cursor = 'pointer';
    }
    // add style prop passed to RI
    Object.assign(style, restProps.style);
    // helper function to merge class names and style objects into the className and style props
    const addToClassAndStyleProps = (addClassName, addStyle) => {
        className = [className, classNameToString(addClassName)]
            .filter((cN) => cN)
            .join(' ');
        Object.assign(style, addStyle);
    };
    // if disabled, add disabled className and style props,
    // otherwise add hover, active, and focus className/style props
    if (disabled) {
        addToClassAndStyleProps(disabledClassName, disabledStyle);
    }
    else {
        if (iState.state.hover) {
            addToClassAndStyleProps(hoverClassName, hoverStyle);
        }
        if (iState.state.active) {
            addToClassAndStyleProps(activeClassName, activeStyle);
            switch (iState.state.active) {
                case 'mouseActive':
                    addToClassAndStyleProps(mouseActiveClassName, mouseActiveStyle);
                    break;
                case 'touchActive':
                    addToClassAndStyleProps(touchActiveClassName, touchActiveStyle);
                    break;
                case 'keyActive':
                    addToClassAndStyleProps(keyActiveClassName, keyActiveStyle);
                    break;
            }
        }
        if (iState.state.focus) {
            addToClassAndStyleProps(focusClassName, focusStyle);
            switch (iState.state.focus) {
                case 'focusFromMouse':
                    addToClassAndStyleProps(focusFromMouseClassName, focusFromMouseStyle);
                    break;
                case 'focusFromTouch':
                    addToClassAndStyleProps(focusFromTouchClassName, focusFromTouchStyle);
                    break;
                case 'focusFromKey':
                    addToClassAndStyleProps(focusFromKeyClassName, focusFromKeyStyle);
                    break;
            }
        }
    }
    // memoize style object so it remains referentially equivalent if the style hasn't changed
    const memoizedStyle = React__namespace.useMemo(() => style, 
    // join styles into string b/c react errors if the dependency array is not the same length each render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Object.entries(style).join()]);
    ////////////////////////////////////
    // disable RI when it is passed a disabled prop
    // note that the RI state will continue to change when disabled
    // but the className and style props are set to disabledClassName and disabledStyle (see above),
    // and click event handlers and href props will be removed
    // disable certain props by setting the value to undefined if RI is disabled
    let disabledProps = null;
    if (disabled) {
        disabledProps = {
            onClick: undefined,
            onClickCapture: undefined,
            onDoubleClick: undefined,
            onDoubleClickCapture: undefined,
            // make elements not focusable when disabled, this also blurs the element if it currently has focus
            tabIndex: undefined,
            // remove href to disable <a> and <area> tags, this also blurs the element if it currently has focus
            // setting href to undefined makes it ok to pass to any element/component, not just <a> and <area>
            href: undefined,
        };
        // if the As DOM element supports the disabled prop, then pass through the disabled prop
        if (elementSupportsDisabled(
        // on the first render localRef.current will be null, but should still pass through disabled prop if supported
        typeof As === 'string'
            ? { tagName: As.toUpperCase() }
            : localRef.current || {})) {
            disabledProps.disabled = true;
        }
    }
    ////////////////////////////////////
    return (React__namespace.createElement(As, Object.assign({}, restProps, eventListeners, disabledProps, { className: className === '' ? undefined : className, style: memoizedStyle, ref: callbackRef }), 
    // if children is a function, then pass it the current interactive state
    typeof children === 'function' ? children(iState.state) : children));
});
// use Object.assign because the properties are required
// by the PolymorphicInteractive interface so can't add them later
const Interactive = Object.assign(React__namespace.memo(InteractiveNotMemoized), {
    // button is the defaultAs for Interactive, so no need to createInteractive('button')
    // but can't set "Button: Interactive" because Interactive hasn't been defined yet
    // so just use React.memo(InteractiveNotMemoized) instead
    Button: React__namespace.memo(InteractiveNotMemoized),
    A: createInteractive('a'),
    Input: createInteractive('input'),
    Select: createInteractive('select'),
    Div: createInteractive('div'),
    Span: createInteractive('span'),
});
function createInteractive(as) {
    // eslint-disable-next-line react/display-name
    const WrappedInteractive = React__namespace.forwardRef(function (props, ref) {
        return React__namespace.createElement(Interactive, Object.assign({}, props, { as: as, ref: ref }));
        // without type casting get TS error on return type of WrappedInteractive
    });
    if (process.env.NODE_ENV !== 'production') {
        WrappedInteractive.displayName = `createInteractive.${typeof as === 'string' ? as : Object(as).displayName}`;
    }
    return WrappedInteractive;
}
if (process.env.NODE_ENV !== 'production') {
    Interactive.displayName = 'Interactive';
}

Object.defineProperty(exports, 'eventFrom', {
  enumerable: true,
  get: function () {
    return eventFrom.eventFrom;
  }
});
Object.defineProperty(exports, 'setEventFrom', {
  enumerable: true,
  get: function () {
    return eventFrom.setEventFrom;
  }
});
exports.Interactive = Interactive;
exports.createInteractive = createInteractive;
//# sourceMappingURL=react-interactive.cjs.development.js.map
