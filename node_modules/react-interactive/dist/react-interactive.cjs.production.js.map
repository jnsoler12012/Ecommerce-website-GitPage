{"version":3,"file":"react-interactive.cjs.production.js","sources":["../src/utils.ts","../src/index.tsx"],"sourcesContent":["import { InteractiveStateChange } from './index';\n\nexport const stateChanged = ({\n  state,\n  prevState,\n}: InteractiveStateChange): boolean =>\n  state.hover !== prevState.hover ||\n  state.active !== prevState.active ||\n  state.focus !== prevState.focus;\n\ninterface ElementTagNameAndType {\n  (element: { tagName?: string; type?: string }): boolean;\n}\n\n// elements triggered by the enter key, used to determine the keyActive state\nexport const enterKeyTrigger: ElementTagNameAndType = ({ tagName, type }) =>\n  tagName !== 'SELECT' &&\n  (tagName !== 'INPUT' || (type !== 'checkbox' && type !== 'radio'));\n\n// elements triggered by the space bar, used to determine the keyActive state\nexport const spaceKeyTrigger: ElementTagNameAndType = ({ tagName, type }) =>\n  ['BUTTON', 'SELECT'].includes(tagName as string) ||\n  (tagName === 'INPUT' &&\n    ['checkbox', 'radio', 'submit'].includes(type as string));\n\n// elements that support the disabled attribute\nexport const elementSupportsDisabled: ElementTagNameAndType = ({ tagName }) =>\n  ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FIELDSET'].includes(\n    tagName as string,\n  );\n\ninterface CursorPointer {\n  (\n    element: { tagName?: string; type?: string },\n    hasOnClickHandler: boolean,\n  ): boolean;\n}\n\n// elements that should have cursor: pointer b/c clicking does something\nexport const cursorPointer: CursorPointer = (\n  { tagName, type },\n  hasOnClickHandler,\n) =>\n  ['BUTTON', 'A', 'AREA', 'SELECT'].includes(tagName as string) ||\n  (tagName === 'INPUT' &&\n    ['checkbox', 'radio', 'submit'].includes(type as string)) ||\n  (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && hasOnClickHandler);\n\n// mimic react's treatment of className prop\n// objects (including arrays) and numbers/bigints\n// are converted to strings, the rest are ignored\nexport const classNameToString = (className: any) =>\n  typeof className === 'string' ||\n  (typeof className === 'object' && className !== null) ||\n  typeof className === 'number' ||\n  typeof className === 'bigint'\n    ? String(className)\n    : '';\n\n// used for useExtendedTouchActive which needs to set user-select: none\n// to prevent the browser from selecting text on long touch\n// note that it needs to be set on the body not the RI element\n// because iOS will still select nearby text\nlet pendingUserSelectReset = false;\n\nexport const setUserSelectNone = (): void => {\n  pendingUserSelectReset = false;\n  document.body.style.userSelect = 'none';\n  document.body.style.webkitUserSelect = 'none';\n};\n\nexport const resetUserSelect = (): void => {\n  pendingUserSelectReset = true;\n  // use setTimeout delay for reset because iOS will select text shortly after touch end\n  // when the touch end event occurs near the time that iOS would normally select text\n  window.setTimeout(() => {\n    if (pendingUserSelectReset) {\n      document.body.style.userSelect = '';\n      document.body.style.webkitUserSelect = '';\n    }\n  }, 250);\n};\n","import * as React from 'react';\nimport { eventFrom, setEventFrom, EventFromInput } from 'event-from';\nimport {\n  stateChanged,\n  enterKeyTrigger,\n  spaceKeyTrigger,\n  cursorPointer,\n  elementSupportsDisabled,\n  classNameToString,\n  setUserSelectNone,\n  resetUserSelect,\n} from './utils';\nimport {\n  PolymorphicForwardRefExoticComponent,\n  PolymorphicPropsWithoutRef,\n  PolymorphicPropsWithRef,\n  PolymorphicMemoExoticComponent,\n} from 'react-polymorphic-types';\n\nexport { eventFrom, setEventFrom, EventFromInput };\n\nexport type ActiveState = 'mouseActive' | 'touchActive' | 'keyActive' | false;\n\nexport type FocusState =\n  | 'focusFromMouse'\n  | 'focusFromTouch'\n  | 'focusFromKey'\n  | false;\n\n/**\n * State object used by React Interactive to determine how the `<Interactive>` component is rendered.\n * The InteractiveState object is also passed to the `onStateChange` callback and `children` (when `children` is a function).\n */\nexport interface InteractiveState {\n  hover: boolean;\n  active: ActiveState;\n  focus: FocusState;\n}\n\nexport type InteractiveStateKey = 'hover' | 'active' | 'focus';\n\n/**\n * InteractiveStateChange is the type for the argument passed to the `onStateChange` callback.\n */\nexport interface InteractiveStateChange {\n  state: InteractiveState;\n  prevState: InteractiveState;\n}\n\nconst initialState: InteractiveState = {\n  hover: false,\n  active: false,\n  focus: false,\n};\n\n// event listeners set by RI\nconst eventMap: Record<string, string> = {\n  mouseover: 'onMouseOver',\n  mouseleave: 'onMouseLeave',\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  pointerover: 'onPointerOver',\n  pointerleave: 'onPointerLeave',\n  pointerdown: 'onPointerDown',\n  pointerup: 'onPointerUp',\n  pointercancel: 'onPointerCancel',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchcancel: 'onTouchCancel',\n  keydown: 'onKeyDown',\n  keyup: 'onKeyUp',\n  focus: 'onFocus',\n  blur: 'onBlur',\n  dragstart: 'onDragStart',\n  dragend: 'onDragEnd',\n};\n\nconst eventListenerPropNames = Object.values(eventMap);\n\nconst defaultAs = 'button';\n\nexport interface InteractiveOwnProps {\n  children?: React.ReactNode | ((state: InteractiveState) => React.ReactNode);\n  onStateChange?: ({ state, prevState }: InteractiveStateChange) => void;\n  disabled?: boolean;\n  useExtendedTouchActive?: boolean;\n  hoverClassName?: string;\n  activeClassName?: string;\n  mouseActiveClassName?: string;\n  touchActiveClassName?: string;\n  keyActiveClassName?: string;\n  focusClassName?: string;\n  focusFromKeyClassName?: string;\n  focusFromMouseClassName?: string;\n  focusFromTouchClassName?: string;\n  disabledClassName?: string;\n  hoverStyle?: React.CSSProperties;\n  activeStyle?: React.CSSProperties;\n  mouseActiveStyle?: React.CSSProperties;\n  touchActiveStyle?: React.CSSProperties;\n  keyActiveStyle?: React.CSSProperties;\n  focusStyle?: React.CSSProperties;\n  focusFromKeyStyle?: React.CSSProperties;\n  focusFromMouseStyle?: React.CSSProperties;\n  focusFromTouchStyle?: React.CSSProperties;\n  disabledStyle?: React.CSSProperties;\n}\n\n/**\n * Usage: `InteractiveProps<'button'>`, or `InteractiveProps<typeof Component>`\n *\n * Only use the `InteractiveProps` type when typing props that are directly passed to an `<Interactive>` component.\n * `InteractiveProps` includes the `as` prop and `ref` prop and should not be used for\n * typing components that wrap an `<Interactive>` component.\n *\n * For typing components that wrap an `<Interactive>` component use the type `InteractiveExtendableProps`\n *\n * For more see: https://github.com/rafgraph/react-interactive#using-with-typescript\n */\nexport type InteractiveProps<\n  T extends React.ElementType = typeof defaultAs\n> = PolymorphicPropsWithRef<InteractiveOwnProps, T>;\n\n/**\n * Usage: `InteractiveExtendableProps<'button'>`, or `InteractiveExtendableProps<typeof Component>`\n *\n * Use the `InteractiveExtendableProps` type when typing components that wrap an `<Interactive>` component\n * where the props are passed through to the `<Interactive>` component.\n *\n * For more see: https://github.com/rafgraph/react-interactive#using-with-typescript\n */\nexport type InteractiveExtendableProps<\n  T extends React.ElementType = typeof defaultAs\n> = Omit<InteractiveProps<T>, 'as' | 'ref'>;\n\n// InteractiveNotMemoized is wrapped in React.memo() and exported at the end of this file\nconst InteractiveNotMemoized: PolymorphicForwardRefExoticComponent<\n  InteractiveOwnProps,\n  typeof defaultAs\n> = React.forwardRef(function <T extends React.ElementType = typeof defaultAs>(\n  {\n    as,\n    children,\n    onStateChange,\n    disabled = false,\n    useExtendedTouchActive = false,\n    hoverClassName = 'hover',\n    activeClassName = 'active',\n    mouseActiveClassName = 'mouseActive',\n    touchActiveClassName = 'touchActive',\n    keyActiveClassName = 'keyActive',\n    focusClassName = 'focus',\n    focusFromKeyClassName = 'focusFromKey',\n    focusFromMouseClassName = 'focusFromMouse',\n    focusFromTouchClassName = 'focusFromTouch',\n    disabledClassName = 'disabled',\n    hoverStyle,\n    activeStyle,\n    mouseActiveStyle,\n    touchActiveStyle,\n    keyActiveStyle,\n    focusStyle,\n    focusFromKeyStyle,\n    focusFromMouseStyle,\n    focusFromTouchStyle,\n    disabledStyle,\n    ...restProps\n  }: PolymorphicPropsWithoutRef<InteractiveOwnProps, T>,\n  ref: React.ForwardedRef<Element>,\n) {\n  ////////////////////////////////////\n\n  // what RI is rendered as in the DOM, default is <button>\n  const As = as || defaultAs;\n\n  ////////////////////////////////////\n\n  // interactive state of the component (hover, active, focus)\n  // save both current and previous state to pass to onStateChange prop callback\n  const [iState, setIState] = React.useState<InteractiveStateChange>({\n    state: initialState,\n    prevState: initialState,\n  });\n\n  // used as a dependency for useEffect, as well as for logic involving useExtendedTouchActive\n  const inTouchActiveState = iState.state.active === 'touchActive';\n\n  ////////////////////////////////////\n\n  // onStateChange prop callback\n  React.useEffect(\n    () => {\n      if (onStateChange) {\n        onStateChange(iState);\n      }\n    },\n    // only call this effect if the current state has changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [iState.state.hover, iState.state.active, iState.state.focus],\n  );\n\n  ////////////////////////////////////\n\n  // if disabled and As is a component, will need to re-render if there is a new ref\n  // to know if the DOM element supports disabled because don't have access to the DOM element on the first render,\n  // the forceUpdate only happens after the first render (and only if disabled and As component),\n  // and when the As component renders a different DOM element while in the disabled state\n  const disabledAndAsComponent = React.useRef<boolean>(false);\n  disabledAndAsComponent.current = disabled && typeof As !== 'string';\n  const [, forceUpdateDisabledComponent] = React.useState(false);\n\n  ////////////////////////////////////\n\n  // support passed in ref prop as object or callback, and track ref locally\n  const localRef = React.useRef<Element | null>(null);\n  const callbackRef = React.useCallback(\n    (node: Element | null) => {\n      localRef.current = node;\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n\n      // if disabled and As is a component, and receive a new ref (i.e. callbackRef is called)\n      // then re-render to pass the disabled prop to the As component if the DOM element supports it\n      if (disabledAndAsComponent.current) {\n        forceUpdateDisabledComponent((s) => !s);\n      }\n    },\n    [ref],\n  );\n\n  ////////////////////////////////////\n\n  // track enter key and space key state (down/up) as ref\n  // used to determine keyActive state\n  const keyTracking = React.useRef<{\n    enterKeyDown: boolean;\n    spaceKeyDown: boolean;\n  }>({ enterKeyDown: false, spaceKeyDown: false });\n\n  // track if the element is being dragged\n  // used to stay in the respective active state while dragging\n  const dragTracking = React.useRef<{\n    isDragging: boolean;\n  }>({ isDragging: false });\n\n  ////////////////////////////////////\n\n  // centralized stateChange function that takes a payload indicating the state change:\n  // - iStateKey: hover | active | focus\n  // - state: the state value to change\n  // - action: enter | exit\n  // action: enter - always enter that state\n  // action: exit - exit that state (to false) only if currently in the specified state, otherwise do nothing\n  // note that entering a state happens as a result of enter/down/start events,\n  // while exiting a state happens as a result of leave/up/end/cancel events (and some others)\n\n  // the stateChange function is idempotent so event handlers can be dumb (don't need to know the current state)\n  // stateChange will bail on updating the state if the state hasn't changed to prevent unnecessary renders\n  // for example mousedown and pointerdown (from mouse) event handlers\n  // will both call stateChange with action enter mouseActive state\n  // the first call will enter the mouseActive state, and the second call will cause stateChange to bail on the state update\n  interface HoverStateChange {\n    iStateKey: 'hover';\n    state: boolean;\n    action: 'enter' | 'exit';\n  }\n  interface ActiveStateChange {\n    iStateKey: 'active';\n    state: ActiveState;\n    action: 'enter' | 'exit';\n  }\n  interface FocusStateChange {\n    iStateKey: 'focus';\n    state: FocusState;\n    action: 'enter' | 'exit';\n  }\n  type StateChangeFunction = (\n    ...changes: (HoverStateChange | ActiveStateChange | FocusStateChange)[]\n  ) => void;\n  const stateChange: StateChangeFunction = React.useCallback((...changes) => {\n    setIState((previous) => {\n      const newState = { ...previous.state };\n      // stateChange accepts multiple changes in each function call\n      // so update the newState for each change received\n      changes.forEach(({ iStateKey, state, action }) => {\n        if (action === 'enter') {\n          // TS should known that iStateKey and state values are matched to each other\n          // based on the StateChangeFunction type above, but TS doesn't understand this, so use as any\n          newState[iStateKey] = state as any;\n        } else if (\n          // only exit a state (to false) if currently in that state\n          action === 'exit' &&\n          previous.state[iStateKey] === state &&\n          // if currently dragging the element, then don't exit the active state\n          (!dragTracking.current.isDragging || iStateKey !== 'active')\n        ) {\n          newState[iStateKey] = false;\n        }\n      });\n      const newInteractiveStateChange = {\n        state: newState,\n        prevState: previous.state,\n      };\n      // if the state has changed (deep equal comparison), then return the newInteractiveStateChange\n      // otherwise bail on the setIState call and return the previous state (object with referential equality)\n      return stateChanged(newInteractiveStateChange)\n        ? newInteractiveStateChange\n        : previous;\n    });\n  }, []);\n\n  ////////////////////////////////////\n  // react bug where the blur event is not dispatched when a button becomes disabled\n  // see https://github.com/facebook/react/issues/9142\n  // so break out blurInteractive() as it's own function\n  // to be called from the blur event handler (normal behavior)\n  // and the below useEffect (workaround for react bug)\n\n  const blurInteractive = React.useCallback(() => {\n    // reset keyTracking when the element is blurred (can't be the target of key events)\n    keyTracking.current.enterKeyDown = false;\n    keyTracking.current.spaceKeyDown = false;\n    stateChange(\n      {\n        iStateKey: 'focus',\n        state: false,\n        action: 'enter',\n      },\n      {\n        iStateKey: 'active',\n        state: 'keyActive',\n        action: 'exit',\n      },\n    );\n  }, [stateChange]);\n\n  // if RI is disabled and in a focus state, then call blur on the DOM element and blurInteractive()\n  React.useEffect(() => {\n    if (\n      disabled &&\n      iState.state.focus &&\n      // if As is a Component that renders an element which doesn't support the disabled attribute (so disabled not passed to the DOM element)\n      // then don't do anything as have no control over what gets rendered (better to just do no harm)\n      // note that for DOM elements that don't support disabled but As is a string (e.g. as=\"div\", as=\"a\")\n      // this works b/c RI also sets tabIndex and href to undefined when disabled which makes the element not focusable\n      // otherwise would get a flash of focus and then blur if the user tried to re-focus the element\n      (elementSupportsDisabled(localRef.current || {}) ||\n        typeof As === 'string')\n    ) {\n      // when a button that currently has focus is disabled there are bugs in both firefox (v87) and safari (v14)\n      // firefox doesn't dispatch a blur event (button is still document.activeElement) but key events are no longer registered on the button, https://bugzilla.mozilla.org/show_bug.cgi?id=1650092\n      // safari leaves focus on the button (no blur event) and key events are still registered, but once focus leaves the button it can't be re-focused\n      // so call blur() on the DOM element to fix these bugs\n      if (\n        localRef.current &&\n        typeof (localRef.current as HTMLElement).blur === 'function'\n      ) {\n        (localRef.current as HTMLElement).blur();\n      }\n\n      blurInteractive();\n    }\n  }, [disabled, iState.state.focus, blurInteractive, As]);\n\n  ////////////////////////////////////\n\n  // handleEvent handles all events that change the interactive state of the component\n  // for example <As onMouseOver={handleEvent} onPointerOver={handleEvent} etc...>\n\n  // always set all pointer/mouse/touch event listeners\n  // instead of just pointer event listeners (when supported by the browser)\n  // or mouse and touch listeners when pointer events are not supported\n  // because\n  //   - 1. the pointer events implementation is buggy on some devices\n  //        so pointer events on its own is not a good option\n  //        for example, on iPadOS pointer events from mouse will cease to fire for the entire page\n  //        after using mouse and touch input at the same time (note that mouse events are unaffected)\n  //   - 2. the pointercancel event is useful for syncing the touchActive state with browser generated click events\n  //        as it fires as soon as the browser uses the touch interaction for another purpose (e.g. scrolling)\n  //        and this can't be replicated with touch events (touchcancel behaves differently)\n  //   - 3. the touchend/cancel event is useful to support useExtendedTouchActive as it won't fire until the\n  //        the touch point is removed from the screen, which can only be replicated with pointer events\n  //        if touch-action: none is set on the element, which has unwanted side effects (e.g. can't scroll if the touch started on the element)\n  // so instead of trying to identify and work around all of the edge cases and bugs and set different listeners in each situation\n  // the solution is to always set all listeners and make the stateChange function idempotent\n  // and bail on updating state in setIState if the state hasn't changed to prevent unnecessary renders\n  // also note that setting listeners for events not supported by the browser has no effect\n\n  // note: use onMouseOver and onPointerOver instead of onMouseEnter and onPointerEnter because\n  // of a react bug where enter events are not dispatched on an element when the element above it is removed,\n  // this also effects when navigating around a single page app where the user clicks on a link\n  // and the element that's rendered on the new page under the mouse doesn't receive enter events\n  // see: https://github.com/facebook/react/issues/13956\n  // note that since stateChange is idempotent the extra mouse/pointer over events will have no effect\n\n  // useCallback so event handlers passed to <As> are referentially equivalent between renders\n  const handleEvent = React.useCallback(\n    (\n      e:\n        | React.MouseEvent\n        | React.PointerEvent\n        | React.TouchEvent\n        | React.KeyboardEvent\n        | React.FocusEvent\n        | React.DragEvent,\n    ) => {\n      // nested switch statement to determine the appropriate stateChange\n      // uses both e.type and eventFrom(e) in its routing logic\n      // switch on e.type\n      //   focus -> focus: enter focusFrom[eventFrom(e)]\n      //   blur -> focus: enter false, active: exit keyActive\n      //   keydown -> active: enter keyActive\n      //   keyup -> active: exit keyActive\n      //   dragstart -> active: enter `${eventFrom(e)}Active`\n      //   dragend -> active: enter false\n      //   default switch on eventFrom(e)\n      //     eventFrom mouse\n      //       switch on e.type\n      //         mouse/pointer over -> hover: enter true\n      //         mouse/pointer leave, pointercancel -> hover: enter false, active: exit mouseActive\n      //         mouse/pointer down -> active: enter mouseActive\n      //         mouse/pointer up -> active: exit mouseActive\n      //     eventFrom touch\n      //       switch on e.type\n      //         touchstart/pointerdown -> active: enter touchActive\n      //         touchend/pointerup/touchcancel/pointercancel/mouseover -> active: exit touchActive\n      //         mouseleave -> hover: enter false, active: exit mouseActive\n      switch (e.type) {\n        case 'focus':\n          // only enter focus state if RI is the target of the focus event (focus events bubble in react)\n          if (e.target === localRef.current) {\n            stateChange({\n              iStateKey: 'focus',\n              state: `focusFrom${eventFrom(e).replace(/^\\w/, (c) =>\n                c.toUpperCase(),\n              )}` as FocusState,\n              action: 'enter',\n            });\n          }\n          break;\n        case 'blur':\n          // break out blur logic as a separate function because of a react bug\n          // where the blur event is not dispatched when a button becomes disabled\n          // so also need to call blurInteractive() after receiving a disabled prop\n          blurInteractive();\n          break;\n        case 'keydown':\n        case 'keyup':\n          // update keyTracking and bail if the event is not from the space or enter key\n          if ((e as React.KeyboardEvent).key === ' ') {\n            keyTracking.current.spaceKeyDown = e.type === 'keydown';\n          } else if ((e as React.KeyboardEvent).key === 'Enter') {\n            keyTracking.current.enterKeyDown = e.type === 'keydown';\n          } else {\n            // break (bail out) if e.key is not the space or enter key so stateChange isn't called\n            break;\n          }\n          stateChange({\n            iStateKey: 'active',\n            state: 'keyActive',\n            action:\n              // use space and enter key down state to determine the enter/exit action\n              // based on what keys trigger the the RI element\n              // some elements are triggered by the space key, some by the enter key, and some by both\n              (keyTracking.current.enterKeyDown &&\n                enterKeyTrigger(localRef.current || {})) ||\n              (keyTracking.current.spaceKeyDown &&\n                spaceKeyTrigger(localRef.current || {}))\n                ? 'enter'\n                : 'exit',\n          });\n          break;\n        case 'dragstart':\n          dragTracking.current.isDragging = true;\n          stateChange({\n            iStateKey: 'active',\n            state: `${eventFrom(e)}Active` as ActiveState,\n            action: 'enter',\n          });\n          break;\n        case 'dragend':\n          dragTracking.current.isDragging = false;\n          stateChange({\n            iStateKey: 'active',\n            state: false,\n            action: 'enter',\n          });\n          break;\n        default:\n          // switch on eventFrom for pointer, mouse, and touch events\n          // for example, a mouse event from mouse input is very different than a mouse event from touch input\n          switch (eventFrom(e)) {\n            case 'mouse':\n              switch (e.type) {\n                case 'mouseover':\n                case 'pointerover':\n                  stateChange({\n                    iStateKey: 'hover',\n                    state: true,\n                    action: 'enter',\n                  });\n                  break;\n                case 'mouseleave':\n                case 'pointerleave':\n                case 'pointercancel':\n                  stateChange(\n                    {\n                      iStateKey: 'hover',\n                      state: false,\n                      action: 'enter',\n                    },\n                    // leave events also exit mouseActive because after the mouse leaves, mouseup events are not fired on the element\n                    // for example, mouse enter -> button down -> mouse leave -> button up, would leave RI stuck in the mouseActive state\n                    {\n                      iStateKey: 'active',\n                      state: 'mouseActive',\n                      action: 'exit',\n                    },\n                  );\n                  break;\n                case 'mousedown':\n                case 'pointerdown':\n                  stateChange({\n                    iStateKey: 'active',\n                    state: 'mouseActive',\n                    action: 'enter',\n                  });\n                  break;\n                case 'mouseup':\n                case 'pointerup':\n                  stateChange({\n                    iStateKey: 'active',\n                    state: 'mouseActive',\n                    action: 'exit',\n                  });\n                  break;\n              }\n              break;\n            case 'touch':\n              switch (e.type) {\n                case 'touchstart':\n                case 'pointerdown':\n                  stateChange({\n                    iStateKey: 'active',\n                    state: 'touchActive',\n                    action: 'enter',\n                  });\n                  break;\n                case 'touchend':\n                case 'touchcancel':\n                case 'pointerup':\n                case 'pointercancel':\n                // exit touchActive on mouseover eventFrom touch\n                // because on android, mouse events (and focus and context menu) fire ~500ms after touch start\n                // once they fire, click will never be fired, so exit touchActive\n                // eslint-disable-next-line no-fallthrough\n                case 'mouseover':\n                  // if useExtendedTouchActive then only exit touchActive on touchend and touchcancel events\n                  // which won't fire until the touch point is removed from the screen\n                  if (\n                    !useExtendedTouchActive ||\n                    ['touchend', 'touchcancel'].includes(e.type)\n                  ) {\n                    stateChange({\n                      iStateKey: 'active',\n                      state: 'touchActive',\n                      action: 'exit',\n                    });\n                  }\n                  break;\n                // when using both mouse and touch input on a hybrid device the following can happen:\n                // the mouse enters an RI element, so hover: true,\n                // then tap someplace else on the screen which fires a mouseleave event\n                // this is correctly treated as an eventFrom touch (caused by a touch interaction)\n                // but RI is now stuck in the hover state\n                // so RI needs to exit the hover state on a mouseleave eventFrom touch,\n                // note that if no scrolling is involved this is not too bad because\n                // when the mouse is used again it will be over the RI element (and will fire mouseover event),\n                // but if the user scrolled with the touch interaction then RI will be stuck in the hover state\n                // until the user re-hovers and exits the RI element with their mouse, which is bad,\n                // also note that on touch only devices this stateChange call will have no effect because RI is never in the hover or mouseActive states\n                case 'mouseleave':\n                  stateChange(\n                    {\n                      iStateKey: 'hover',\n                      state: false,\n                      action: 'enter',\n                    },\n                    {\n                      iStateKey: 'active',\n                      state: 'mouseActive',\n                      action: 'exit',\n                    },\n                  );\n                  break;\n              }\n              break;\n          }\n          break;\n      }\n\n      // call event handler prop for the current event if the prop is passed in\n      if (restProps[eventMap[e.type] as any]) {\n        restProps[eventMap[e.type] as any](e);\n      }\n    },\n    // handleEvent is dependent on event handler props that are also in eventMap\n    // for example, restProps.onMouseOver, restProps.onTouchStart, etc\n    // this generates an array of event handler props that are also in eventMap\n    // handleEvent is also dependent on stateChange, but this will always be referentially equivalent\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      ...eventListenerPropNames.map(\n        (listenerPropName) => restProps[listenerPropName as any],\n      ),\n      useExtendedTouchActive,\n      stateChange,\n      blurInteractive,\n    ],\n  );\n\n  ////////////////////////////////////\n\n  // create object with event listeners to pass to <As {...eventListeners}>\n  const eventListeners: Record<string, React.ReactEventHandler> = {};\n  eventListenerPropNames.forEach((listenerPropName) => {\n    eventListeners[listenerPropName] = handleEvent;\n  });\n\n  ////////////////////////////////////\n\n  // to sync the touchActive state with the click event fired by the browser\n  // only stay in the touchActive state for a max of 750ms\n  // note that most of the time another event (up/end/cancel) will exit touchActive before the timer finishes\n  // in which case the effect clean up will run (because inTouchActiveState state changed)\n  // and the timer will be cleared\n\n  // track touchActive timer id as ref\n  const touchActiveTimeoutId = React.useRef<number | undefined>(undefined);\n\n  // effect run on touchActive state change, or if useExtendedTouchActive prop changes\n  // it will always clear the existing timer before potentially setting a new one\n  React.useEffect(() => {\n    if (inTouchActiveState && !useExtendedTouchActive) {\n      touchActiveTimeoutId.current = window.setTimeout(() => {\n        stateChange({\n          iStateKey: 'active',\n          state: 'touchActive',\n          action: 'exit',\n        });\n      }, 750);\n\n      return () => window.clearTimeout(touchActiveTimeoutId.current);\n    }\n    return;\n  }, [inTouchActiveState, useExtendedTouchActive, stateChange]);\n\n  ////////////////////////////////////\n\n  // set user-select: none when useExtendedTouchActive and in the touchActive state\n  // to prevent the browser from selecting text on long touch\n  // note that it needs to be set on the body not the RI element\n  // because iOS will still select nearby text if it is only set on the element\n  React.useEffect(() => {\n    if (inTouchActiveState && useExtendedTouchActive) {\n      setUserSelectNone();\n      return resetUserSelect;\n    }\n    return;\n  }, [inTouchActiveState, useExtendedTouchActive]);\n\n  ////////////////////////////////////\n\n  // compute className and style props based on the current state\n\n  // css classes are merged into this string\n  let className: string = classNameToString(restProps.className);\n\n  // style objects are merged into this object with the following precedence:\n  // style object <= default styles <= style prop <= (disabledStyle || hoverStyle <= activeStyle <= [input]ActiveStyle <= focusStyle <= focusFrom[input]Style)\n  const style: React.CSSProperties = {};\n\n  // add default styles\n  if (\n    // if clicking does something and RI is not disabled, then set the cursor to pointer for better UX\n    !disabled &&\n    cursorPointer(\n      localRef.current || {},\n      Boolean(restProps.onClick || restProps.onClickCapture),\n    )\n  ) {\n    style.cursor = 'pointer';\n  }\n\n  // add style prop passed to RI\n  Object.assign(style, restProps.style);\n\n  // helper function to merge class names and style objects into the className and style props\n  const addToClassAndStyleProps = (\n    addClassName: string,\n    addStyle?: React.CSSProperties,\n  ) => {\n    className = [className, classNameToString(addClassName)]\n      .filter((cN) => cN)\n      .join(' ');\n    Object.assign(style, addStyle);\n  };\n\n  // if disabled, add disabled className and style props,\n  // otherwise add hover, active, and focus className/style props\n  if (disabled) {\n    addToClassAndStyleProps(disabledClassName, disabledStyle);\n  } else {\n    if (iState.state.hover) {\n      addToClassAndStyleProps(hoverClassName, hoverStyle);\n    }\n\n    if (iState.state.active) {\n      addToClassAndStyleProps(activeClassName, activeStyle);\n      switch (iState.state.active) {\n        case 'mouseActive':\n          addToClassAndStyleProps(mouseActiveClassName, mouseActiveStyle);\n          break;\n        case 'touchActive':\n          addToClassAndStyleProps(touchActiveClassName, touchActiveStyle);\n          break;\n        case 'keyActive':\n          addToClassAndStyleProps(keyActiveClassName, keyActiveStyle);\n          break;\n      }\n    }\n\n    if (iState.state.focus) {\n      addToClassAndStyleProps(focusClassName, focusStyle);\n      switch (iState.state.focus) {\n        case 'focusFromMouse':\n          addToClassAndStyleProps(focusFromMouseClassName, focusFromMouseStyle);\n          break;\n        case 'focusFromTouch':\n          addToClassAndStyleProps(focusFromTouchClassName, focusFromTouchStyle);\n          break;\n        case 'focusFromKey':\n          addToClassAndStyleProps(focusFromKeyClassName, focusFromKeyStyle);\n          break;\n      }\n    }\n  }\n\n  // memoize style object so it remains referentially equivalent if the style hasn't changed\n  const memoizedStyle = React.useMemo(\n    () => style,\n    // join styles into string b/c react errors if the dependency array is not the same length each render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [Object.entries(style).join()],\n  );\n\n  ////////////////////////////////////\n\n  // disable RI when it is passed a disabled prop\n  // note that the RI state will continue to change when disabled\n  // but the className and style props are set to disabledClassName and disabledStyle (see above),\n  // and click event handlers and href props will be removed\n\n  // disable certain props by setting the value to undefined if RI is disabled\n  let disabledProps: Record<string, undefined | boolean> | null = null;\n  if (disabled) {\n    disabledProps = {\n      onClick: undefined,\n      onClickCapture: undefined,\n      onDoubleClick: undefined,\n      onDoubleClickCapture: undefined,\n      // make elements not focusable when disabled, this also blurs the element if it currently has focus\n      tabIndex: undefined,\n      // remove href to disable <a> and <area> tags, this also blurs the element if it currently has focus\n      // setting href to undefined makes it ok to pass to any element/component, not just <a> and <area>\n      href: undefined,\n    };\n\n    // if the As DOM element supports the disabled prop, then pass through the disabled prop\n    if (\n      elementSupportsDisabled(\n        // on the first render localRef.current will be null, but should still pass through disabled prop if supported\n        typeof As === 'string'\n          ? { tagName: (As as string).toUpperCase() }\n          : localRef.current || {},\n      )\n    ) {\n      disabledProps.disabled = true;\n    }\n  }\n\n  ////////////////////////////////////\n\n  return (\n    <As\n      {...restProps}\n      {...eventListeners}\n      {...disabledProps}\n      className={className === '' ? undefined : className}\n      style={memoizedStyle}\n      ref={callbackRef}\n    >\n      {\n        // if children is a function, then pass it the current interactive state\n        typeof children === 'function' ? children(iState.state) : children\n      }\n    </As>\n  );\n});\n\ntype InteractivePropsWithoutAs<\n  T extends React.ElementType = typeof defaultAs\n> = Omit<InteractiveProps<T>, 'as'>;\n\ninterface PolymorphicInteractive\n  extends PolymorphicMemoExoticComponent<\n    InteractiveOwnProps,\n    typeof defaultAs\n  > {\n  Button: React.ForwardRefExoticComponent<InteractivePropsWithoutAs<'button'>>;\n  A: React.ForwardRefExoticComponent<InteractivePropsWithoutAs<'a'>>;\n  Input: React.ForwardRefExoticComponent<InteractivePropsWithoutAs<'input'>>;\n  Select: React.ForwardRefExoticComponent<InteractivePropsWithoutAs<'select'>>;\n  Div: React.ForwardRefExoticComponent<InteractivePropsWithoutAs<'div'>>;\n  Span: React.ForwardRefExoticComponent<InteractivePropsWithoutAs<'span'>>;\n}\n\n// use Object.assign because the properties are required\n// by the PolymorphicInteractive interface so can't add them later\nexport const Interactive: PolymorphicInteractive = Object.assign(\n  React.memo(InteractiveNotMemoized),\n  {\n    // button is the defaultAs for Interactive, so no need to createInteractive('button')\n    // but can't set \"Button: Interactive\" because Interactive hasn't been defined yet\n    // so just use React.memo(InteractiveNotMemoized) instead\n    Button: React.memo(InteractiveNotMemoized),\n    A: createInteractive('a'),\n    Input: createInteractive('input'),\n    Select: createInteractive('select'),\n    Div: createInteractive('div'),\n    Span: createInteractive('span'),\n  },\n);\n\nexport function createInteractive<\n  T extends React.ElementType = typeof defaultAs\n>(as: T): React.ForwardRefExoticComponent<InteractivePropsWithoutAs<T>> {\n  // eslint-disable-next-line react/display-name\n  const WrappedInteractive = React.forwardRef(function <\n    T extends React.ElementType = typeof as\n  >(\n    props: PolymorphicPropsWithoutRef<InteractiveOwnProps, T>,\n    ref: React.ForwardedRef<Element>,\n  ) {\n    return <Interactive {...props} as={as} ref={ref} />;\n    // without type casting get TS error on return type of WrappedInteractive\n  }) as React.ForwardRefExoticComponent<InteractivePropsWithoutAs<T>>;\n  if (process.env.NODE_ENV !== 'production') {\n    WrappedInteractive.displayName = `createInteractive.${\n      typeof as === 'string' ? as : Object(as).displayName\n    }`;\n  }\n  return WrappedInteractive;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  Interactive.displayName = 'Interactive';\n}\n"],"names":["enterKeyTrigger","tagName","type","spaceKeyTrigger","includes","elementSupportsDisabled","classNameToString","className","String","pendingUserSelectReset","resetUserSelect","window","setTimeout","document","body","style","userSelect","webkitUserSelect","initialState","hover","active","focus","eventMap","mouseover","mouseleave","mousedown","mouseup","pointerover","pointerleave","pointerdown","pointerup","pointercancel","touchstart","touchend","touchcancel","keydown","keyup","blur","dragstart","dragend","eventListenerPropNames","Object","values","InteractiveNotMemoized","React","forwardRef","as","children","onStateChange","disabled","useExtendedTouchActive","hoverClassName","activeClassName","mouseActiveClassName","touchActiveClassName","keyActiveClassName","focusClassName","focusFromKeyClassName","focusFromMouseClassName","focusFromTouchClassName","disabledClassName","hoverStyle","activeStyle","mouseActiveStyle","touchActiveStyle","keyActiveStyle","focusStyle","focusFromKeyStyle","focusFromMouseStyle","focusFromTouchStyle","disabledStyle","restProps","ref","As","iState","setIState","useState","state","prevState","inTouchActiveState","useEffect","disabledAndAsComponent","useRef","current","forceUpdateDisabledComponent","localRef","callbackRef","useCallback","node","s","keyTracking","enterKeyDown","spaceKeyDown","dragTracking","isDragging","stateChange","changes","previous","newState","forEach","iStateKey","action","newInteractiveStateChange","stateChanged","blurInteractive","handleEvent","e","target","eventFrom","replace","c","toUpperCase","key","map","listenerPropName","eventListeners","touchActiveTimeoutId","undefined","clearTimeout","hasOnClickHandler","cursorPointer","Boolean","onClick","onClickCapture","cursor","assign","addToClassAndStyleProps","addClassName","addStyle","filter","cN","join","memoizedStyle","useMemo","entries","disabledProps","onDoubleClick","onDoubleClickCapture","tabIndex","href","Interactive","memo","Button","A","createInteractive","Input","Select","Div","Span","props"],"mappings":"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"}